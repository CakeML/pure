(*
  Proof of correctness for the pure_to_thunk compiler pass.
 *)
open HolKernel Parse boolLib bossLib term_tactic monadsyntax;
open stringTheory optionTheory sumTheory pairTheory listTheory alistTheory
     finite_mapTheory pred_setTheory rich_listTheory thunkLang_substTheory
     pure_evalTheory thunkLang_primitivesTheory;

val _ = new_theory "pure_to_thunkProof";

(* TODO: Move to pure_to_thunk

   Some variables point to computations that have been
   suspended by a lambda on the thunkLang side. These variables
   need to be forced, and are thus tagged with ‘Suspended’.
 *)

Datatype:
  vmode = Raw | Suspended
End

(*
  NOTES ON COMPILING PURELANG TO THUNKLANG:

  thunkLang_subst-pureLang simulation.

  As pureLang is lazy it allows non-functional value declarations that are
  mutually recursive, and lazy value declarations. All such computations are
  suspended behind a “Delay T (Closure «fresh_var»  «defn»)” thunkLang-side.
  We keep track of which variables are suspended and which are not using a
  context.

  * [Var]
    - ‘Suspended’ variables are forced thunkLang-side.
    - ‘Raw’ variables are evaluated as-is.
  * [Lam]
    - Lambdas are already lazy. The bound variable is treated as ‘Raw’.
  * [App]
    - The function argument is evaluated in the same way on both sides, but
      the function argument computation is suspended thunkLang-side by wrapping
      it in a “Delay T (Closure ...)”-thing (using a fresh variable).
  * [Prim]
    - ‘If’ receives special treatment because we need it to retain its laziness
      in thunkLang (Why isn't it possible to suspend the branches by wrapping
      them in ‘Delay’? Because the way the semantics is set up, a ‘Delay’
      produces a “Thunk” value that can only be dealt with by the semantics of
      ‘Force’. But if we wrap both branches with ‘Force’ it's essentially a
      no-op). A valid ‘If’ requires three arguments and that's basically it.
    - ‘Cons’ receives special treatment. I think we should treat constructor
      application as an n-ary “App”.
    - Non-‘Cons’/‘If’ ops should still receive laziness but I'm not sure how
      it should happen.
  * [Letrec]
    - TODO

  Various TODO:
    - Something looked fishy with the thunkLang substitution. I think could be
      helpful if it gets stuck with a Type_error when we substitute in non-
      closed expressions.
    - The clocks seem to be a bit off between the two semantics. I tried to
      line them up a bit already, but there might be some discrepancies still.
      I was able to avoid some cases by ignoring expressions that cause the
      pureLang semantics to get stuck with wh_Errors.
 *)

Inductive exp_rel:
[exp_rel_Var_Suspended:]
  (∀ctxt n.
     ALOOKUP ctxt n = SOME Suspended ⇒
       exp_rel ctxt (Var n) (Force (Var n))) ∧
[exp_rel_Var_Raw:]
  (∀ctxt n.
     ALOOKUP ctxt n = SOME Raw ⇒
       exp_rel ctxt (Var n) (Var n)) ∧
[exp_rel_Lam:]
  (∀ctxt s (x: pure_exp$exp) (x': thunkLang_subst$exp).
     exp_rel ((s, Raw)::ctxt) x x' ⇒
       exp_rel ctxt (Lam s x) (Lam s x')) ∧
[exp_rel_App:]
  (∀ctxt x x' y y' s.
     exp_rel ctxt x x' ∧
     exp_rel ctxt y y' ∧
     s ∉ freevars y ⇒
       exp_rel ctxt (App x y) (App x' (Delay T (Lam s y')))) ∧
[exp_rel_If:]
  (∀ctxt xs x y z.
     LENGTH xs = 3 ∧
     exp_rel ctxt (EL 0 xs) x ∧
     exp_rel ctxt (EL 1 xs) y ∧
     exp_rel ctxt (EL 2 xs) z ⇒
       exp_rel ctxt (Prim If xs) (If x y z)) ∧
[exp_rel_Cons:]
  (∀ctxt xs ys n m.
     LIST_REL (λx y.
       ∃s. s ∉ freevars y ∧
           exp_rel ctxt x (Delay T (Lam s y))) xs ys ∧
     n = m ⇒
       exp_rel ctxt (Prim (Cons n) xs) (Prim (Cons m) ys)) ∧
[exp_rel_Prim:]
  (∀ctxt op xs xs'.
     op ≠ If ∧
     (∀n. op ≠ Cons n) ∧
     LIST_REL (exp_rel ctxt) xs xs' ⇒
       exp_rel ctxt (Prim op xs) (Prim op xs')) ∧
[exp_rel_Letrec:]
  (∀ctxt f f' x x'.
     exp_rel ctxt (Letrec f x) (Letrec f' x'))
     (* FIXME This bit will involve more context-fiddling *)
End

(*

TODO:
  It would be nice if this theorem could be generated in a nicer way (that does
  not involve the ‘funpow X rator’ stuff), and even better if it could be
  generated by Inductive.

TypeBase.case_def_of “:pure_exp$exp”
|> CONJUNCTS
|> map (rand o funpow 5 rator o rand o rator o concl o SPEC_ALL)
|> map (fn t => SIMP_CONV (srw_ss()) [Once exp_rel_cases] “exp_rel ctxt ^t y”)
 *)

Theorem exp_rel_def[local]:
  (∀n.
     exp_rel ctxt (Var n) y ⇔
       (ALOOKUP ctxt n = SOME Suspended ∧
        y = Force (Var n)) ∨
       (ALOOKUP ctxt n = SOME Raw ∧
        y = Var n)) ∧
  (∀s x.
     exp_rel ctxt (Lam s x) y ⇔
       ∃z. y = Lam s z ∧
           exp_rel ((s, Raw)::ctxt) x z) ∧
  (∀op xs.
     exp_rel ctxt (Prim op xs) y ⇔
       (∃x1 x2 x3.
          y = If x1 x2 x3 ∧
          op = If ∧
          LENGTH xs = 3 ∧
          exp_rel ctxt (EL 0 xs) x1 ∧
          exp_rel ctxt (EL 1 xs) x2 ∧
          exp_rel ctxt (EL 2 xs) x3) ∨
       (∃xs' n.
          y = Prim op xs' ∧
          op = Cons n ∧
          LIST_REL (λx y.
            ∃s. s ∉ freevars y ∧ exp_rel ctxt x (Delay T (Lam s y))) xs xs') ∨
       (∃xs'.
          y = Prim op xs' ∧
          op ≠ If ∧
          (∀n. op ≠ Cons n) ∧
          LIST_REL (exp_rel ctxt) xs xs')) ∧
  (∀f x.
     exp_rel ctxt (App f x) y ⇔
       ∃g z s.
         y = App g (Delay T (Lam s z)) ∧
         s ∉ freevars x ∧
         exp_rel ctxt f g ∧
         exp_rel ctxt x z)
Proof
  rw []
  \\ simp [Once exp_rel_cases]
  \\ eq_tac
  \\ rw [] \\ gs []
QED

(*
  TODO: The name thunk_rel doesn't say much
 *)

Inductive thunk_rel:
  (∀ctxt x s y.
     exp_rel ctxt x y ⇒
       thunk_rel ctxt x (Thunk T (Closure s y))) ∧
  (∀ctxt x k y v.
    exp_rel ctxt x y ∧
    eval_to k y = INR v ⇒
      thunk_rel ctxt x (Thunk F v))
End

Theorem thunk_rel_def[local]:
  thunk_rel ctxt x (Thunk T e) =
    (∃s y.
       e = Closure s y ∧
       exp_rel ctxt x y) ∧
  thunk_rel ctxt x (Thunk F v) =
    (∃k y.
       exp_rel ctxt x y ∧
       eval_to k y = INR v)
Proof
  rw [] \\ simp [Once thunk_rel_cases]
QED

(*
  We use the pureLang semantics that evaluates to weak head normal form.
  Error, Diverge and Closure are related to their thunkLang counterparts in
  the obvious way. Constructors are related as follows: constructor names are
  the same, the number of arguments are the same, and each argument to the
  constructor pureLang-side is related to a (possibly suspended) computation
  wrapped in “Thunk” on the thunkLang-side. See above for thunk_rel.

  (This was based on a discussion with Magnus. “thunk_rel” is perhaps a
  description of how laziness is supposed to work around constructors?)

  TODO
    This is wrong: Thunk values are not related to anything. I think a
    normalized thunk should maybe be related to the same things as its body,
    and a non-normalized thunk should (a) have a lambda and (b) be related to
    the lambda body.

    Then v_rel has to become inductive. (Not really an issue.)

 *)

Definition v_rel_def:
  v_rel ctxt wh_Error (INL Type_error) = T ∧
  v_rel ctxt wh_Diverge (INL Diverge) = T ∧
  v_rel ctxt (wh_Closure s x) (INR (Closure t y)) =
    (s = t ∧ exp_rel ((s, Raw)::ctxt) x y) ∧
  v_rel ctxt (wh_Constructor s xs) (INR (Constructor t ys)) =
    (s = t ∧ LIST_REL (thunk_rel ctxt) xs ys) ∧
  v_rel ctxt (wh_Atom a) (INR (Atom b)) = (a = b) ∧
  v_rel ctxt _ _ = F
End

Theorem v_rel_rev[local]:
  v_rel ctxt x (INL Type_error) = (x = wh_Error) ∧
  v_rel ctxt x (INL Diverge) = (x = wh_Diverge) ∧
  v_rel ctxt x (INR (Closure s y)) =
    (∃b.
       x = wh_Closure s b ∧
       exp_rel ((s, Raw)::ctxt) b y) ∧
  v_rel ctxt x (INR (Constructor s ys)) =
    (∃xs.
       x = wh_Constructor s xs ∧
       LIST_REL (thunk_rel ctxt) xs ys)
Proof
  Cases_on ‘x’ \\ rw [v_rel_def, EQ_IMP_THM] \\ fs []
QED

(* Hmm
Theorem exp_rel_bind:
  exp_rel ctxt x y ∧
  thunk_rel ctxt z w ⇒
    exp_rel ctxt (bind s z x) (bind1 s w y)
Proof
  cheat
QED
 *)

Theorem exp_rel_eval_to:
  ∀k x res y ctxt.
    eval_wh_to k x = res ∧
    res ≠ wh_Error ∧
    exp_rel ctxt x y ⇒
      v_rel ctxt res (eval_to k y)
Proof
  ho_match_mp_tac eval_wh_to_ind
  \\ rpt conj_tac
  \\ rpt gen_tac
  >- ((* Var *)
    rw [eval_wh_to_def, eval_to_def])
  >- ((* Lam *)
    rw [eval_wh_to_def, exp_rel_def]
    \\ simp [eval_to_def, v_rel_def])
  >- ((* App *)
    strip_tac
    \\ rpt gen_tac
    \\ simp [eval_wh_to_def]
    \\ IF_CASES_TAC \\ fs []
    >- ((* pure sem diverges *)
      rw [exp_rel_def]
      \\ simp [eval_to_def]
      \\ IF_CASES_TAC \\ fs [v_rel_def]
      \\ ‘∃r. eval_to (k - 1) g = r’ by fs []
      \\ first_x_assum (drule_then assume_tac)
      \\ ‘eval_to k g = INL Diverge’
        by (Cases_on ‘eval_to k g’ \\ fs [v_rel_def]
            \\ rename1 ‘err = Diverge’
            \\ Cases_on ‘err’ \\ fs [v_rel_def])
      \\ ‘eval_to (k - 1) g = INL Diverge’ suffices_by rw [v_rel_def]
      \\ CCONTR_TAC
      \\ ‘k - 1 < k’ by fs []
      \\ drule_all_then assume_tac eval_to_subst_mono \\ gs [])
    \\ Cases_on ‘dest_wh_Closure (eval_wh_to k x)’ \\ csimp []
    \\ BasicProvers.TOP_CASE_TAC \\ fs []
    \\ IF_CASES_TAC \\ fs []
    >- ((* pure sem diverges *)
      strip_tac
      \\ fs [exp_rel_def, eval_to_def, v_rel_def])
    \\ strip_tac
    \\ ‘eval_wh_to k x ≠ wh_Error’ by (strip_tac \\ fs [])
    \\ gvs [exp_rel_def]
    \\ first_x_assum (drule_all_then assume_tac)
    \\ simp [eval_to_def]
      (* TODO
           Prove lemma about substituted expressions:
             exp_rel between the bound thing (bind (q, y, r)) in pureLang,
             in some context ((q,Raw)::ctxt ?) with some corresponding thing
             in thunkLang.
       *)
    \\ cheat)
  >- ((* Letrec *)
    cheat (* TODO Not done *))
  >- ((* Prim *)
    rename1 ‘Prim op xs’
    \\ rw [exp_rel_def]
    >- ((* If *)
      simp [eval_to_def, eval_wh_to_def]
      \\ IF_CASES_TAC \\ fs [v_rel_def]
      \\ gvs [LENGTH_EQ_NUM_compute]
      \\ map_every rename1 [
          ‘exp_rel ctxt y1 x1’,
          ‘exp_rel ctxt y2 x2’,
          ‘exp_rel ctxt y3 x3’]
      \\ fsrw_tac [boolSimps.DNF_ss] []
      \\ fs [eval_wh_to_def, CaseEq "wh", CaseEq "bool"]
      \\ first_x_assum (drule_then assume_tac)
      \\ CASE_TAC \\ Cases_on ‘eval_to (k - 1) x1’ \\ fs [v_rel_def]
      \\ rename1 ‘INR res’
      \\ Cases_on ‘res’ \\ fs [v_rel_def])
    >- ((* ¬ If *)
      simp [eval_to_def, eval_wh_to_def]
      \\ IF_CASES_TAC \\ fs [v_rel_def]
      \\ rename1 ‘LIST_REL _ xs ys’
      \\ Cases_on ‘op’ \\ fs [do_prim_def]
      >- ((* Cons *)
        cheat (* TODO thunk_rel *))
      >- ((* IsEq *)
        fs [eval_wh_to_def]
        \\ IF_CASES_TAC \\ gvs [LENGTH_EQ_NUM_compute]
        \\ rename1 ‘exp_rel ctxt x y’
        \\ Cases_on ‘eval_wh_to (k - 1) x = wh_Error’ \\ fs []
        \\ first_x_assum (drule_then strip_assume_tac)
        \\ simp [map_def]
        \\ Cases_on ‘eval_wh_to (k - 1) x’
        \\ Cases_on ‘eval_to (k - 1) y’
        \\ fs [v_rel_def, CaseEq "bool"]
        \\ rename1 ‘v_rel _ _ (INR res)’
        \\ Cases_on ‘res’ \\ gvs [v_rel_def]
        \\ IF_CASES_TAC \\ fs [v_rel_def]
        \\ IF_CASES_TAC \\ fs [v_rel_def]
        \\ fs [LIST_REL_EL_EQN])
      >- ((* Proj *)
        fs [eval_wh_to_def]
        \\ IF_CASES_TAC \\ gvs [LENGTH_EQ_NUM_compute]
        \\ rename1 ‘exp_rel ctxt x y’
        \\ Cases_on ‘eval_wh_to (k - 1) x = wh_Error’ \\ fs []
        \\ first_x_assum (drule_then strip_assume_tac)
        \\ simp [map_def]
        \\ Cases_on ‘eval_wh_to (k - 1) x’
        \\ Cases_on ‘eval_to (k - 1) y’
        \\ fs [v_rel_def, CaseEq "bool"]
        \\ rename1 ‘v_rel _ _ (INR res)’
        \\ Cases_on ‘res’ \\ gvs [v_rel_def]
        \\ cheat (* LIST_REL thunk_rel currently doesn't say much *))
      >- ((* AtomOp *)
        fs [eval_wh_to_def, CaseEq "option"]
        \\ CASE_TAC \\ fs []
        >- (
          gvs [get_atoms_NONE_eq, EL_MAP, LIST_REL_EL_EQN]
          \\ ‘eval_to (k - 1) (EL n ys) = INL Diverge’
            by (‘MEM (EL n xs) xs’ by fs [EL_MEM]
                \\ first_x_assum (drule_then assume_tac)
                \\ ‘eval_wh_to (k - 1) (EL n xs) ≠ wh_Error’ by fs []
                \\ first_x_assum (drule_all_then assume_tac)
                \\ Cases_on ‘eval_to (k - 1) (EL n ys)’ \\ gs [v_rel_def]
                \\ rename1 ‘INL err’ \\ Cases_on ‘err’ \\ fs [v_rel_def])
          \\ ‘∀m. m < n ⇒ ∃a. eval_to (k - 1) (EL m ys) = INR (Atom a)’
            by (rw []
                \\ ‘m < LENGTH ys’ by fs []
                \\ first_x_assum (drule_then strip_assume_tac)
                \\ first_x_assum (drule_then strip_assume_tac)
                \\ ‘MEM (EL m xs) xs’ by fs [EL_MEM]
                \\ first_x_assum (drule_then assume_tac)
                \\ ‘eval_wh_to (k - 1) (EL m xs) ≠ wh_Error’ by fs []
                \\ first_x_assum (drule_all_then assume_tac)
                \\ Cases_on ‘eval_to (k - 1) (EL m ys)’ \\ gs [v_rel_def]
                \\ rename1 ‘INR res’ \\ Cases_on ‘res’ \\ fs [v_rel_def])
          \\ Cases_on ‘map (λx. eval_to (k - 1) x) ys’ \\ fs []
          >- (
            gvs [map_INL]
            \\ rename1 ‘eval_to _ (EL m ys) = INL err’
            \\ ‘n ≤ m’
              by (CCONTR_TAC
                  \\ ‘m < n’ by fs []
                  \\ first_x_assum (drule_then strip_assume_tac)
                  \\ gs [])
            \\ Cases_on ‘m = n’ \\ fs [v_rel_def])
          \\ drule map_INR
          \\ disch_then (drule_then strip_assume_tac) \\ fs [])
        \\ gvs [GSYM (AP_TERM “$¬” (SPEC_ALL optionTheory.NOT_IS_SOME_EQ_NONE)),
                IS_SOME_EXISTS, get_atoms_SOME_SOME_eq, EVERY2_MAP]
        \\ Cases_on ‘map (λx. eval_to (k - 1) x) ys’ \\ fs []
        >- (
          gvs [map_INL, LIST_REL_EL_EQN]
          \\ first_x_assum (drule_then assume_tac)
          \\ first_x_assum (drule_then assume_tac)
          \\ ‘MEM (EL n xs) xs’ by fs [EL_MEM]
          \\ first_x_assum (drule_then assume_tac)
          \\ ‘eval_wh_to (k - 1) (EL n xs) ≠ wh_Error’ by fs []
          \\ first_x_assum (drule_all_then assume_tac)
          \\ gs [v_rel_def])
        \\ rename1 ‘map _ _ = INR res’
        \\ drule_then assume_tac map_INR
        \\ gvs [LIST_REL_EL_EQN]
        \\ drule_then assume_tac map_LENGTH
        \\ cheat (* TODO lemma about get_lits *))
      >- ((* Lit *)
        gvs [eval_wh_to_def, CaseEq "bool", map_def, v_rel_def])))
QED

val _ = export_theory ();

