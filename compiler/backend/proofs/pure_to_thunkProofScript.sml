(*
  Proof of correctness for the pure_to_thunk compiler pass.
 *)
open HolKernel Parse boolLib bossLib term_tactic monadsyntax;
open stringTheory optionTheory sumTheory pairTheory listTheory alistTheory
     finite_mapTheory pred_setTheory rich_listTheory thunkLang_substTheory
     pure_evalTheory thunkLang_primitivesTheory;

val _ = new_theory "pure_to_thunkProof";

(* TODO: Move to pure_to_thunk

   Some variables point to computations that have been
   suspended by a lambda on the thunkLang side. These variables
   need to be forced, and are thus tagged with ‘Suspended’.
 *)

Datatype:
  vmode = Raw | Suspended
End

(*
  NOTES ON COMPILING PURELANG TO THUNKLANG:

  thunkLang_subst-pureLang simulation.

  As pureLang is lazy it allows non-functional value declarations that are
  mutually recursive, and lazy value declarations. All such computations are
  suspended behind a “Delay T (Closure «fresh_var»  «defn»)” thunkLang-side.
  We keep track of which variables are suspended and which are not using a
  context.

  * [Var]
    - ‘Suspended’ variables are forced thunkLang-side.
    - ‘Raw’ variables are evaluated as-is.
  * [Lam]
    - Lambdas are already lazy. The bound variable is treated as ‘Raw’.
  * [App]
    - The function argument is evaluated in the same way on both sides, but
      the function argument computation is suspended thunkLang-side by wrapping
      it in a “Delay T (Closure ...)”-thing (using a fresh variable).
  * [Prim]
    - ‘If’ receives special treatment because we need it to retain its laziness
      in thunkLang (Why isn't it possible to suspend the branches by wrapping
      them in ‘Delay’? Because the way the semantics is set up, a ‘Delay’
      produces a “Thunk” value that can only be dealt with by the semantics of
      ‘Force’. But if we wrap both branches with ‘Force’ it's essentially a
      no-op). A valid ‘If’ requires three arguments and that's basically it.
    - ‘Cons’ receives special treatment. I think we should treat constructor
      application as an n-ary “App”.
    - Non-‘Cons’/‘If’ ops should still receive laziness but I'm not sure how
      it should happen.
  * [Letrec]
    - TODO

  Various TODO:
    - Something looked fishy with the thunkLang substitution. I think could be
      helpful if it gets stuck with a Type_error when we substitute in non-
      closed expressions.
    - The clocks seem to be a bit off between the two semantics. I tried to
      line them up a bit already, but there might be some discrepancies still.
      I was able to avoid some cases by ignoring expressions that cause the
      pureLang semantics to get stuck with wh_Errors.
 *)

Inductive exp_rel:
[exp_rel_Var_Suspended:]
  (∀ctxt n.
     ALOOKUP ctxt n = SOME Suspended ⇒
       exp_rel ctxt (Var n) (Force (Var n))) ∧
[exp_rel_Var_Raw:]
  (∀ctxt n.
     ALOOKUP ctxt n = SOME Raw ⇒
       exp_rel ctxt (Var n) (Var n)) ∧
[exp_rel_Lam:]
  (∀ctxt s (x: pure_exp$exp) (x': thunkLang_subst$exp).
     exp_rel ((s, Raw)::ctxt) x x' ⇒
       exp_rel ctxt (Lam s x) (Lam s x')) ∧
[exp_rel_App:]
  (∀ctxt x x' y y' s.
     exp_rel ctxt x x' ∧
     exp_rel ctxt y y' ∧
     s ∉ freevars y ⇒
       exp_rel ctxt (App x y) (App x' (Delay T (Lam s y')))) ∧
[exp_rel_If:]
  (∀ctxt xs x y z.
     LENGTH xs = 3 ∧
     exp_rel ctxt (EL 0 xs) x ∧
     exp_rel ctxt (EL 1 xs) y ∧
     exp_rel ctxt (EL 2 xs) z ⇒
       exp_rel ctxt (Prim If xs) (If x y z)) ∧
[exp_rel_Cons:]
  (∀ctxt xs ys n m.
     LIST_REL (λx y.
       ∃s. s ∉ freevars y ∧
           exp_rel ctxt x (Delay T (Lam s y))) xs ys ∧
     n = m ⇒
       exp_rel ctxt (Prim (Cons n) xs) (Prim (Cons m) ys)) ∧
[exp_rel_Prim:]
  (∀ctxt op xs xs'.
     op ≠ If ∧
     (∀n. op ≠ Cons n) ∧
     LIST_REL (exp_rel ctxt) xs xs' ⇒
       exp_rel ctxt (Prim op xs) (Prim op xs')) ∧
[exp_rel_Letrec:]
  (∀ctxt f f' x x'.
     exp_rel ctxt (Letrec f x) (Letrec f' x'))
     (* FIXME This bit will involve more context-fiddling *)
End

(*

TODO:
  It would be nice if this theorem could be generated in a nicer way (that does
  not involve the ‘funpow X rator’ stuff), and even better if it could be
  generated by Inductive.

TypeBase.case_def_of “:pure_exp$exp”
|> CONJUNCTS
|> map (rand o funpow 5 rator o rand o rator o concl o SPEC_ALL)
|> map (fn t => SIMP_CONV (srw_ss()) [Once exp_rel_cases] “exp_rel ctxt ^t y”)
 *)

Theorem exp_rel_def[local]:
  (∀n.
     exp_rel ctxt (Var n) y ⇔
       (ALOOKUP ctxt n = SOME Suspended ∧
        y = Force (Var n)) ∨
       (ALOOKUP ctxt n = SOME Raw ∧
        y = Var n)) ∧
  (∀s x.
     exp_rel ctxt (Lam s x) y ⇔
       ∃z. y = Lam s z ∧
           exp_rel ((s, Raw)::ctxt) x z) ∧
  (∀op xs.
     exp_rel ctxt (Prim op xs) y ⇔
       (∃x1 x2 x3.
          y = If x1 x2 x3 ∧
          op = If ∧
          LENGTH xs = 3 ∧
          exp_rel ctxt (EL 0 xs) x1 ∧
          exp_rel ctxt (EL 1 xs) x2 ∧
          exp_rel ctxt (EL 2 xs) x3) ∨
       (∃xs' n.
          y = Prim op xs' ∧
          op = Cons n ∧
          LIST_REL (λx y.
            ∃s. s ∉ freevars y ∧ exp_rel ctxt x (Delay T (Lam s y))) xs xs') ∨
       (∃xs'.
          y = Prim op xs' ∧
          op ≠ If ∧
          (∀n. op ≠ Cons n) ∧
          LIST_REL (exp_rel ctxt) xs xs')) ∧
  (∀f x.
     exp_rel ctxt (App f x) y ⇔
       ∃g z s.
         y = App g (Delay T (Lam s z)) ∧
         s ∉ freevars x ∧
         exp_rel ctxt f g ∧
         exp_rel ctxt x z)
Proof
  rw []
  \\ simp [Once exp_rel_cases]
  \\ eq_tac
  \\ rw [] \\ gs []
QED

(*
  TODO: The name thunk_rel doesn't say much
 *)

Inductive thunk_rel:
  (∀ctxt x s y.
     exp_rel ctxt x y ⇒
       thunk_rel ctxt x (Thunk T (Closure s y))) ∧
  (∀ctxt x k y v.
    exp_rel ctxt x y ∧
    eval_to k y = INR v ⇒
      thunk_rel ctxt x (Thunk F v))
End

Theorem thunk_rel_def[local]:
  thunk_rel ctxt x (Thunk T e) =
    (∃s y.
       e = Closure s y ∧
       exp_rel ctxt x y) ∧
  thunk_rel ctxt x (Thunk F v) =
    (∃k y.
       exp_rel ctxt x y ∧
       eval_to k y = INR v)
Proof
  rw [] \\ simp [Once thunk_rel_cases]
QED

(*
  We use the pureLang semantics that evaluates to weak head normal form.
  Error, Diverge and Closure are related to their thunkLang counterparts in
  the obvious way. Constructors are related as follows: constructor names are
  the same, the number of arguments are the same, and each argument to the
  constructor pureLang-side is related to a (possibly suspended) computation
  wrapped in “Thunk” on the thunkLang-side. See above for thunk_rel.

  (This was based on a discussion with Magnus. “thunk_rel” is perhaps a
  description of how laziness is supposed to work around constructors?)

  TODO
    This is wrong: Thunk values are not related to anything. I think a
    normalized thunk should maybe be related to the same things as its body,
    and a non-normalized thunk should (a) have a lambda and (b) be related to
    the lambda body.

    Then v_rel has to become inductive. (Not really an issue.)

 *)

Definition v_rel_def:
  v_rel ctxt wh_Error (INL Type_error) = T ∧
  v_rel ctxt wh_Diverge (INL Diverge) = T ∧
  v_rel ctxt (wh_Closure s x) (INR (Closure t y)) =
    (s = t ∧ exp_rel ((s, Raw)::ctxt) x y) ∧
  v_rel ctxt (wh_Constructor s xs) (INR (Constructor t ys)) =
    (s = t ∧ LIST_REL (thunk_rel ctxt) xs ys) ∧
  v_rel ctxt (wh_Atom a) (INR (Atom b)) = (a = b) ∧
  v_rel ctxt _ _ = F
End

Theorem v_rel_rev[local]:
  v_rel ctxt x (INL Type_error) = (x = wh_Error) ∧
  v_rel ctxt x (INL Diverge) = (x = wh_Diverge) ∧
  v_rel ctxt x (INR (Closure s y)) =
    (∃b.
       x = wh_Closure s b ∧
       exp_rel ((s, Raw)::ctxt) b y) ∧
  v_rel ctxt x (INR (Constructor s ys)) =
    (∃xs.
       x = wh_Constructor s xs ∧
       LIST_REL (thunk_rel ctxt) xs ys)
Proof
  Cases_on ‘x’ \\ rw [v_rel_def, EQ_IMP_THM] \\ fs []
QED

(* Hmm
Theorem exp_rel_bind:
  exp_rel ctxt x y ∧
  thunk_rel ctxt z w ⇒
    exp_rel ctxt (bind s z x) (bind1 s w y)
Proof
  cheat
QED
 *)

Theorem get_lits_map[local]:
  get_lits = map (λx. case x of Atom l => INR l | _ => INL Type_error)
Proof
  simp [FUN_EQ_THM]
  \\ Induct \\ simp [get_lits_def, map_def]
QED

Theorem exp_rel_eval_to:
  ∀k x res y ctxt.
    eval_wh_to k x = res ∧
    exp_rel ctxt x y ⇒
      v_rel ctxt res (eval_to k y)
Proof
  ho_match_mp_tac eval_wh_to_ind
  \\ rpt conj_tac
  \\ rpt gen_tac
  >- ((* Var *)
    rw [eval_wh_to_def, eval_to_def]
    \\ fs [exp_rel_def, v_rel_def, eval_to_def])
  >- ((* Lam *)
    rw [eval_wh_to_def, exp_rel_def]
    \\ simp [eval_to_def, v_rel_def])
  >- ((* App *)
    strip_tac
    \\ rpt gen_tac
    \\ simp [eval_wh_to_def]
    \\ IF_CASES_TAC \\ fs []
    >- ((* pure sem diverges *)
      rw [exp_rel_def]
      \\ simp [eval_to_def]
      \\ first_x_assum (drule_then assume_tac)
      \\ Cases_on ‘eval_to k g’ \\ fs [v_rel_def])
    \\ rw [exp_rel_def]
    \\ first_x_assum (drule_then assume_tac)
    \\ rw [eval_to_def]
    \\ Cases_on ‘eval_wh_to k x = wh_Error’ \\ fs []
    >- ((* pure sem errors *)
      simp [eval_to_def]
      \\ Cases_on ‘eval_to k g’ \\ fs [v_rel_def])
    \\ ‘∃res. eval_to k g = INR res’
      by (Cases_on ‘eval_to k g’ \\ fs []
          \\ rename1 ‘INL err’
          \\ Cases_on ‘err’ \\ fs [v_rel_rev])
    \\ simp []
    \\ Cases_on ‘dest_wh_Closure (eval_wh_to k x)’ \\ fs []
    >- ((* not a pureLang closure: thunk sem must also error *)
      Cases_on ‘eval_wh_to k x’ \\ Cases_on ‘res’ \\ gvs [v_rel_def]
      \\ simp [thunkLang_substTheory.dest_anyClosure_def,
               thunkLang_substTheory.dest_Closure_def,
               thunkLang_substTheory.dest_Recclosure_def,
               v_rel_def])
    \\ BasicProvers.TOP_CASE_TAC \\ fs []
    \\ Cases_on ‘eval_wh_to k x’ \\ gvs [dest_wh_Closure_def]
    \\ Cases_on ‘res’ \\ gvs [dest_anyClosure_def,
                              thunkLang_substTheory.dest_Closure_def,
                              v_rel_def]
    \\ IF_CASES_TAC \\ fs [v_rel_def]
    \\ first_x_assum irule
    \\ simp [pure_expTheory.bind_def, FLOOKUP_UPDATE]
    \\ cheat
      (* TODO
           lemma about exp_rel and bound thunk stuff.
           we need for substitution to fail on both sides unless
           the expression (body) is closed.
       *))
  >- ((* Letrec *)
    cheat (* TODO Not done *))
  >- ((* Prim *)
    rename1 ‘Prim op xs’
    \\ rw [exp_rel_def]
    >- ((* If *)
      simp [eval_to_def, eval_wh_to_def]
      \\ IF_CASES_TAC \\ fs [v_rel_def]
      \\ gvs [LENGTH_EQ_NUM_compute]
      \\ fsrw_tac [boolSimps.DNF_ss] []
      \\ rpt (first_x_assum (drule_then assume_tac))
      \\ rename1 ‘exp_rel ctxt y1 x1’
      \\ CASE_TAC \\ Cases_on ‘eval_to (k - 1) x1’ \\ fs [v_rel_def]
      \\ rename1 ‘INR res’ \\ Cases_on ‘res’ \\ gvs [v_rel_def]
      \\ IF_CASES_TAC \\ fs []
      \\ IF_CASES_TAC \\ fs []
      \\ IF_CASES_TAC \\ fs []
      \\ IF_CASES_TAC \\ fs [v_rel_def])
    >- ((* Cons *)
      simp [eval_wh_to_def, eval_to_def]
      \\ IF_CASES_TAC \\ fs [v_rel_def]
      \\ rename1 ‘LIST_REL _ xs ys’
      (* TODO
         - I think that thunk_rel should be about something like this:
       *)
      \\ ‘LIST_REL (λx y. ∃s. s ∉ freevars y ∧
                              v_rel ctxt (eval_wh_to (k - 1) x)
                                         (INR (Thunk T (Closure s y)))) xs ys’
        by (fs [LIST_REL_EL_EQN] \\ rw [] \\ gvs []
            \\ first_x_assum (drule_then strip_assume_tac)
            \\ ‘MEM (EL n xs) xs’ by fs [EL_MEM]
            \\ first_x_assum (drule_then drule_all)
            \\ simp [eval_to_def]
            \\ disch_then (irule_at Any) \\ fs [])
      (* TODO
         - There's an issue here with `map` even if we adjust thunk_rel to match
           the LIST_REL above: the evaluation of the arguments can fail here,
           and the whole semantics will get stuck. There should be an
           invariant expressed somewhere that all constructor arguments are
           properly suspended so that their evaluation always succeeds!
       *)
      \\ cheat)
    >- ((* ∉ {If; Cons} *)
      simp [eval_to_def, eval_wh_to_def]
      \\ IF_CASES_TAC \\ fs [v_rel_def]
      \\ rename1 ‘LIST_REL _ xs ys’
      \\ Cases_on ‘op’ \\ fs [do_prim_def]
      >- ((* IsEq *)
        fs [eval_wh_to_def]
        \\ IF_CASES_TAC \\ gvs [LENGTH_EQ_NUM_compute]
        >- ((* pure sem errors *)
          cheat (* TODO this shouldn't happen because of the same reason
                        as with Cons above *)
        )
        \\ rename1 ‘exp_rel ctxt x y’
        \\ first_x_assum (drule_then strip_assume_tac)
        \\ simp [map_def]
        \\ Cases_on ‘eval_wh_to (k - 1) x’
        \\ Cases_on ‘eval_to (k - 1) y’
        \\ fs [v_rel_def, CaseEq "bool"]
        \\ rename1 ‘v_rel _ _ (INR res)’
        \\ Cases_on ‘res’ \\ gvs [v_rel_def]
        \\ IF_CASES_TAC \\ gvs [v_rel_def]
        \\ IF_CASES_TAC \\ gvs [v_rel_def, LIST_REL_EL_EQN])
      >- ((* Proj *)
        fs [eval_wh_to_def]
        \\ IF_CASES_TAC \\ gvs [LENGTH_EQ_NUM_compute]
        >- ((* pure sem errors *)
          cheat (* TODO this shouldn't happen because of the same reason
                        as with Cons above *)
        )
        \\ rename1 ‘exp_rel ctxt x y’
        \\ first_x_assum (drule_then strip_assume_tac)
        \\ simp [map_def]
        \\ Cases_on ‘eval_wh_to (k - 1) x’
        \\ Cases_on ‘eval_to (k - 1) y’
        \\ fs [v_rel_def, CaseEq "bool"]
        \\ rename1 ‘v_rel _ _ (INR res)’
        \\ Cases_on ‘res’ \\ gvs [v_rel_def]
        \\ rename1 ‘s1 = s2 ∧ n < LENGTH l1’
        \\ rename1 ‘LIST_REL _ l1 l2’
        \\ reverse (Cases_on ‘s1 = s2 ∧ n < LENGTH l1’) \\ fs []
        >- (
          ‘¬(s1 = s2 ∧ n < LENGTH l1)’ by fs []
          \\ ‘¬(s1 = s2 ∧ n < LENGTH l2)’ by gvs [LIST_REL_EL_EQN]
          \\ asm_simp_tac std_ss [v_rel_def])
        \\ gvs [LIST_REL_EL_EQN]
        \\ cheat (* TODO fix thunk_rel *))
      >- ((* AtomOp *)
        fs [eval_wh_to_def, CaseEq "option"]
        (* TODO get_atoms and get_lits should produce the same stuff *)
        \\ cheat
        (*
        \\ CASE_TAC \\ fs []
        >- (
          gvs [get_atoms_NONE_eq, EL_MAP, LIST_REL_EL_EQN]
          \\ ‘eval_to (k - 1) (EL n ys) = INL Diverge’
            by (‘MEM (EL n xs) xs’ by fs [EL_MEM]
                \\ first_x_assum (drule_then assume_tac)
                \\ ‘eval_wh_to (k - 1) (EL n xs) ≠ wh_Error’ by fs []
                \\ first_x_assum (drule_all_then assume_tac)
                \\ Cases_on ‘eval_to (k - 1) (EL n ys)’ \\ gs [v_rel_def]
                \\ rename1 ‘INL err’ \\ Cases_on ‘err’ \\ fs [v_rel_def])
          \\ ‘∀m. m < n ⇒ ∃a. eval_to (k - 1) (EL m ys) = INR (Atom a)’
            by (rw []
                \\ ‘m < LENGTH ys’ by fs []
                \\ first_x_assum (drule_then strip_assume_tac)
                \\ first_x_assum (drule_then strip_assume_tac)
                \\ ‘MEM (EL m xs) xs’ by fs [EL_MEM]
                \\ first_x_assum (drule_then assume_tac)
                \\ ‘eval_wh_to (k - 1) (EL m xs) ≠ wh_Error’ by fs []
                \\ first_x_assum (drule_all_then assume_tac)
                \\ Cases_on ‘eval_to (k - 1) (EL m ys)’ \\ gs [v_rel_def]
                \\ rename1 ‘INR res’ \\ Cases_on ‘res’ \\ fs [v_rel_def])
          \\ Cases_on ‘map (λx. eval_to (k - 1) x) ys’ \\ fs []
          >- (
            gvs [map_INL]
            \\ rename1 ‘eval_to _ (EL m ys) = INL err’
            \\ ‘n ≤ m’
              by (CCONTR_TAC
                  \\ ‘m < n’ by fs []
                  \\ first_x_assum (drule_then strip_assume_tac)
                  \\ gs [])
            \\ Cases_on ‘m = n’ \\ fs [v_rel_def])
          \\ drule map_INR
          \\ disch_then (drule_then strip_assume_tac) \\ fs [])
        \\ gvs [GSYM (AP_TERM “$¬” (SPEC_ALL optionTheory.NOT_IS_SOME_EQ_NONE)),
                IS_SOME_EXISTS, get_atoms_SOME_SOME_eq, EVERY2_MAP]
        \\ Cases_on ‘map (λx. eval_to (k - 1) x) ys’ \\ fs []
        >- (
          gvs [map_INL, LIST_REL_EL_EQN]
          \\ first_x_assum (drule_then assume_tac)
          \\ first_x_assum (drule_then assume_tac)
          \\ ‘MEM (EL n xs) xs’ by fs [EL_MEM]
          \\ first_x_assum (drule_then assume_tac)
          \\ ‘eval_wh_to (k - 1) (EL n xs) ≠ wh_Error’ by fs []
          \\ first_x_assum (drule_all_then assume_tac)
          \\ gs [v_rel_def])
        \\ rename1 ‘map _ _ = INR res’
        \\ rename1 ‘LIST_REL _ xs zs’
        \\ fs [LIST_REL_EL_EQN]
        \\ drule_then assume_tac map_INR \\ fs []
        \\ Cases_on ‘get_lits res’
        >- ((* errors *)
          gvs [get_lits_map, map_INL]
          \\ drule_then assume_tac map_LENGTH \\ gvs []
          \\ ‘MEM (EL n xs) xs’ by fs [EL_MEM]
          \\ last_x_assum (drule_then assume_tac)
          \\ ‘eval_wh_to (k - 1) (EL n xs) ≠ wh_Error’ by fs []
          \\ ‘exp_rel ctxt (EL n xs) (EL n ys)’ by fs [] \\ fs []
          \\ first_x_assum (drule_then assume_tac) \\ gs []
          \\ Cases_on ‘EL n res’ \\ gs [v_rel_def])
        \\ fs []
        \\ rename1 ‘get_lits res = INR ws’
        \\ drule_then assume_tac map_LENGTH \\ fs [get_lits_map]
        \\ drule_then assume_tac map_LENGTH \\ gvs []
        \\ qsuff_tac ‘∀n. n < LENGTH zs ⇒ EL n zs = EL n ws’
        >- (
          strip_tac
          \\ ‘LENGTH zs = LENGTH ws’ by fs []
          \\ drule LIST_EQ \\ rw []
          \\ fs [v_rel_def])
        \\ rw []
        \\ ‘MEM (EL n xs) xs’ by fs [EL_MEM]
        \\ last_x_assum (drule_then assume_tac)
        \\ ‘eval_wh_to (k - 1) (EL n xs) ≠ wh_Error’ by fs []
        \\ ‘exp_rel ctxt (EL n xs) (EL n ys)’ by fs [] \\ fs []
        \\ first_x_assum (drule_then assume_tac) \\ gs []
        \\ drule_then (qspec_then ‘n’ assume_tac) map_INR \\ gs []
        \\ Cases_on ‘EL n res’ \\ gvs []
        \\ fs [v_rel_def] *))
      >- ((* Lit *)
        IF_CASES_TAC \\ gvs [map_def, v_rel_def]
        \\ Cases_on ‘map (λy. eval_to (k - 1) y) ys’ \\ fs []
        >- ((* thunk sem errors; it shouldn't *)
          cheat (* TODO same as above about args *))
        \\ drule_then assume_tac map_LENGTH
        \\ IF_CASES_TAC \\ gvs [LIST_REL_EL_EQN, v_rel_def])))
QED

val _ = export_theory ();

